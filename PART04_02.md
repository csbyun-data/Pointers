🔹 4.2 유효하지 않은 주소 참조
✅ 개요

유효하지 않은 주소 참조란,
포인터가 이미 해제된 메모리나 범위를 벗어난 변수를 가리킬 때 발생합니다.

이 상태의 포인터를 **Dangling Pointer(댕글링 포인터)**라고 부릅니다.

✅ 예시 1: 해제된 메모리를 참조
```cpp
int* p = new int(42);
delete p;        // 메모리 해제
*p = 10;         // ❌ 정의되지 않은 동작 (dangling pointer)
```

이 상태에서 *p를 사용하는 것은 위험합니다.
→ 해당 메모리는 이미 시스템에 반환되었기 때문입니다.

✅ 예시 2: 지역 변수의 주소 반환
```cpp
int* getPtr() {
    int local = 5;
    return &local;   // ❌ 지역 변수는 함수 종료 시 사라짐
}

int main() {
    int* p = getPtr();
    std::cout << *p << std::endl;  // ❌ 유효하지 않은 참조
}
```

함수 내부 지역 변수는 스택 메모리에 저장되며,
함수 종료 시 해당 메모리는 무효화됩니다.

✅ 예시 3: 배열 범위 밖 접근
int arr[3] = {1, 2, 3};
int* p = arr + 5;   // ❌ 유효하지 않은 메모리 참조
std::cout << *p << std::endl;  // UB (undefined behavior)

✅ 예시 4: STL 컨테이너의 포인터 무효화
```cpp
std::vector<int> v = {1, 2, 3};
int* p = &v[0];

v.push_back(4);     // 메모리 재할당 발생 가능
std::cout << *p;    // ❌ p는 더 이상 유효하지 않을 수 있음
```

벡터는 크기 확장 시 내부 메모리를 새로 할당하면서
기존 주소가 무효화되므로 주의해야 합니다.

✅ Dangling Pointer 방지 방법
| 상황            | 해결 방법                    |
| ------------- | ------------------------ |
| `delete` 후    | 포인터를 `nullptr`로 초기화      |
| 지역 변수 주소 반환   | 반환 전에 값을 복사하거나 동적 할당 사용  |
| 컨테이너 내부 주소 저장 | 인덱스나 반복자(iterator) 사용 권장 |
| 유효성 체크        | 사용 전 항상 null 또는 범위 검사    |

✅ 예: 안전하게 사용하는 코드
```cpp
int* p = new int(100);
delete p;
p = nullptr;      // 안전한 상태로 초기화

if (p != nullptr) {
    *p = 50;
} else {
    std::cout << "Pointer is null.\n";
}
```
📌 요약
| 항목               | 설명                                     |
| ---------------- | -------------------------------------- |
| Dangling Pointer | 더 이상 유효하지 않은 메모리를 가리키는 포인터             |
| 발생 원인            | delete 후, 지역 변수 주소 반환, 배열 범위 벗어남 등     |
| 위험성              | 정의되지 않은 동작(UB), 크래시, 보안 취약점 발생         |
| 방지책              | 포인터를 `nullptr`로 초기화, 범위 내 접근, 참조 관리 철저 |
