## Part 1. 포인터 기본 개념

포인터는 메모리 주소를 직접 다루는 프로그래밍 도구로, 고급 자료구조 구현, 동적 메모리 관리, 
함수 간 데이터 공유 등에서 매우 중요합니다. 

이 장에서는 포인터를 본격적으로 사용하기 전에 반드시 알아야 할 기본 개념들을 다룹니다.

---

### 1.0.1 포인터란 무엇인가

포인터(pointer)란 **메모리 주소를 저장하는 변수** 입니다. 일반 변수는 데이터를 저장하지만, 
포인터는 그 데이터의 위치(주소)를 저장합니다.

```c
int a = 10;       // 일반 변수 선언
int *p = &a;      // 포인터 p는 변수 a의 주소를 저장
                  // int *p; p = &a; 를 줄여 쓴 문장
printf("%d, %p\n", *p, (void*)p);
```
* &a는 변수 a의 주소를 의미합니다
* *p는 주소가 아니라, 포인터 p가 가리키는 값 (즉, *p == a == 10)입니다.

| 변수 | 주소 | 값                  |
| -- | ------ | ------------------- |
| a  | 0x1000 | 10                  |
| p  | 0x2000 | 0x1000 (a의 주소)   |
| &a |        | 0x1000              |
| *p |        | 10                  |


예제 1: 포인터를 이용한 값 출력
```c
#include <stdio.h>
int main() {
    int x = 42;
    int *ptr = &x;
    printf("x의 값: %d, %p\n", *ptr, (void*)ptr); // 42
    return 0;
}
```
###  1.0.2 메모리와 변수, 주소 개념
컴퓨터의 메모리는 바이트 단위로 구분된 공간입니다. 변수는 이 공간에 데이터를 저장하며,
각 변수는 고유한 **주소(address)** 를 갖습니다.

주소 얻기
```c
int x = 5;
printf("x의 주소: %p\n", &x);
```
%p: 포인터(주소)를 출력하는 형식 지정자

예제 2: 변수의 주소 확인
```c
#include <stdio.h>
int main() {
    int a = 7;
    float b = 3.14;
    printf("a의 주소: %p\n", (void*)&a);
    printf("b의 주소: %p\n", (void*)&b);
    return 0;
}
```
### 1.0.3 변수와 포인터 관계
포인터는 변수의 주소를 저장하고, * 연산자를 이용해 해당 주소에 저장된 값을 읽거나 수정할 수 있습니다.
이를 **간접 참조(indirection)**, **역참조(dereferencing)** 라고 합니다.

예제 3: 포인터를 이용한 값 변경
```c
#include <stdio.h>
int main() {
    int a = 10;
    int *p = &a;

    printf("Before: a = %d\n", a);
    *p = 20;  // p가 가리키는 주소의 값 변경
    printf("After: a = %d\n", a);  // 20
    return 0;
}
```
### 1.0.4 포인터가 필요한 이유
1. 함수 간 데이터 공유 (Call by Reference, 포인터 이용)
```c
void modify(int *p) {
    *p = 100;
}

int main() {
    int a = 5;
    modify(&a);
    printf("%d\n", a);  // 100
}
```
2. 동적 메모리 할당
실행 중 필요한 만큼 메모리를 확보 (malloc, new)

3. 배열 및 문자열 처리
```c
char *str = "Hello";
printf("%c\n", *(str + 1));  // 'e'
```
4. 동적 자료구조 구현
연결 리스트, 트리, 그래프 등은 포인터 없이는 불가능

### 1.0.5 포인터 크기와 자료형
포인터의 크기는 시스템 아키텍처에 따라 다릅니다.
| 시스템  | 포인터 크기 |
| ---- | ------ |
| 32비트 | 4바이트   |
| 64비트 | 8바이트   |

포인터 자료형은 해당 주소를 어떻게 해석할지 결정합니다.

예제 4: 포인터 크기 확인
```c
#include <stdio.h>
int main() {
    int *ip;
    double *dp;
    char *cp;

    printf("int * 크기: %zu\n", sizeof(ip));
    printf("double * 크기: %zu\n", sizeof(dp));
    printf("char * 크기: %zu\n", sizeof(cp));
    return 0;
}
```
📌 sizeof(ip)는 포인터 자체의 크기, 즉 주소값 크기

### 1.0.6 포인터와 메모리 레이아웃 이해
C 프로그램은 다음과 같은 메모리 구조로 실행됩니다:

```sql

  높은 주소
  +-------------+
  | 스택(Stack) | ← 지역 변수, 함수 호출
  +-------------+
  |  힙(Heap)   | ← 동적 메모리 (malloc, new 등)
  +-------------+
  | 데이터 영역 | ← 전역/정적 변수
  +-------------+
  | 코드 영역   | ← 실행 코드
  낮은 주소
```
예제 5: 힙과 스택의 주소 비교
```c
#include <stdio.h>
#include <stdlib.h>

int global_var = 100; // 데이터 영역

int main() {
  int local_var = 10;        // 스택
  int *heap_var = malloc(sizeof(int)); // 힙
  *heap_var = 20;

  printf("data, global_var: %p\n", (void*)&global_var);
  printf("stack, local_var : %p\n", (void*)&local_var);
  printf("heap, heap_var  : %p\n", (void*)heap_var);

  free(heap_var);
  return 0;
}
```
결과는 시스템에 따라 다르지만 일반적으로: 스택 주소 > 힙 주소 > 데이터 주소

✅ 연습 문제
1. 정수형 변수 a를 선언하고 포인터를 이용하여 값을 변경하시오.

2. 두 개의 정수를 더하는 함수를 만들되, 포인터를 사용하여 결과를 호출자에게 전달하시오.

3. 포인터를 이용해 문자열을 출력하는 코드를 작성하시오.

📚 요약
| 항목       | 설명                        |
| -------- | ------------------------- |
| 포인터      | 메모리 주소를 저장하는 변수           |
| `&`      | 주소 연산자                    |
| `*`      | 간접 참조 연산자                 |
| 포인터의 크기  | 시스템 아키텍처(32/64bit)에 따라 결정 |
| 메모리 레이아웃 | 코드, 데이터, 힙, 스택으로 구성       |
