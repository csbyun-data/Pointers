## 1.0 포인터 기본 개념

포인터는 메모리 주소를 직접 다루는 프로그래밍 도구로, 고급 자료구조 구현, 동적 메모리 관리, 
함수 간 데이터 공유 등에서 매우 중요합니다. 

이 장에서는 포인터를 본격적으로 사용하기 전에 반드시 알아야 할 기본 개념들을 다룹니다.

---

### 1.0.1 포인터란 무엇인가

포인터(pointer)란 `메모리 주소를 저장하는 변수`입니다. 일반 변수는 데이터를 저장하고, 
포인터는 그 데이터의 위치(주소)를 저장합니다.

```c
int a = 10;       // 일반 변수 선언
int *p = &a;      // 변수 a의 주소를 포인터 p에 저장
                  // int *p; p = &a; 를 줄여 쓴 문장
printf("%d, %p\n", *p, (void*)p);
```
* &a는 변수 a의 주소를 의미합니다
* *p는 주소가 아니라, 포인터 p가 가리키는 값 (즉, *p == a == 10)

| 변수 | 주소 | 값                  |
| -- | ------ | ------------------- |
| a  | 0x1000 | 10                  |
| p  | 0x2000 | 0x1000 (a의 주소)   |
| &a |        | 0x1000              |
| *p |        | 10                  |


예제 1: 포인터를 이용한 값 출력
```c
#include <stdio.h>
int main() {
    int x = 42;
    int *ptr = &x;
    printf("x의 값: %d, %p\n", *ptr, (void*)ptr); // 42
    return 0;
}
```
###  1.0.2 메모리와 변수, 주소 개념
컴퓨터의 메모리는 바이트 단위로 구분된 공간입니다. 변수는 이 공간에 데이터를 저장하며,
각 변수는 고유한 `주소(address)`를 갖습니다.

주소 얻기
```c
int x = 5;
printf("x의 주소: %p\n", (void*)&x);
```
  * %p: 포인터(주소)를 출력하는 형식 지정자입니다.

예제 2: 변수의 주소 확인
```c
#include <stdio.h>
int main() {
    int a = 7;
    float b = 3.14;
    printf("a의 주소: %p\n", (void*)&a);
    printf("b의 주소: %p\n", (void*)&b);
    return 0;
}
```

### 1.0.3 변수와 포인터 관계
포인터는 변수의 주소를 저장하고, * 연산자를 이용해 해당 주소에 저장된 값을 읽거나 수정할 수 있습니다.
이를 `간접 참조(indirection)` 또는 `역참조(dereferencing)`라고 합니다.

예제 3: 포인터를 이용한 값 변경
```c
#include <stdio.h>
int main() {
    int a = 10;
    int *p = &a;

    printf("Before: a = %d\n", a);
    *p = 20;  // p가 가리키는 주소의 값 변경
    printf("After: a = %d\n", a);  // 20
    return 0;
}
```
### 1.0.4 포인터가 필요한 이유
1. 함수 간 데이터 공유 (Call by Reference, 포인터 이용)
```c
void modify(int *p) {
    *p = 100;
}

int main() {
    int a = 5;
    modify(&a);
    printf("%d\n", a);  // 100
}
```
2. 동적 메모리 할당  
  * 실행 중 필요한 만큼 메모리를 확보 (e.g., malloc, new)

3. 배열 및 문자열 처리
```c
char *str = "Hello";
printf("%c\n", *(str + 1));  // 'e'
printf("%c\n", str[1]);      // 'e'
```
```c
char *str = "Hello";     // 문자열 상수 (읽기 전용)
char arr[] = "Hello";    // 배열 (수정 가능)
```
📌 문자열을 포인터로 선언하면 수정이 불가능하거나 정의되지 않은 동작이 생길 수 있습니다.

4. 동적 자료구조 구현  
  * 포인터는 연결 리스트, 트리, 그래프 등의 동적 자료구조 구현에 필수적입니다.

### 1.0.5 포인터 크기와 자료형
포인터의 크기는 시스템 아키텍처에 따라 다릅니다.
| 시스템  | 포인터 크기 |
| ---- | ------ |
| 32비트 | 4바이트   |
| 64비트 | 8바이트   |

포인터 자료형은 해당 주소를 어떻게 해석할지 결정합니다.

예제 4: 포인터 크기 확인
```c
#include <stdio.h>
int main() {
    int *ip;
    double *dp;
    char *cp;

    printf("int * 크기: %zu\n", sizeof(ip));
    printf("double * 크기: %zu\n", sizeof(dp));
    printf("char * 크기: %zu\n", sizeof(cp));
    return 0;
}
```
📌 sizeof(ip)는 포인터 자체의 크기, 즉 주소값의 크기를 나타냅니다.
예제 5: 포인터 타입에 따른 차이
```c
int a = 100;
int *ip = &a;
char *cp = (char*)&a;

printf("%d\n", *ip); // 100
printf("%d\n", *cp); // 100, 하지만 1바이트만 해석
```
📌 주소는 같아도, 자료형에 따라 읽는 바이트 수가 다릅니다.

### 1.0.6 포인터와 메모리 레이아웃 이해
C 프로그램은 일반적으로 다음과 같은 메모리 구조를 가집니다:

```text

  높은 주소
  +-------------+
  | 스택(Stack) | ← 지역 변수, 함수 호출
  +-------------+
  |  힙(Heap)   | ← 동적 메모리 (malloc, new 등)
  +-------------+
  | 데이터 영역 | ← 전역/정적 변수
  +-------------+
  | 코드 영역   | ← 실행 코드

  낮은 주소
```
📌스택이 높은 주소에 위치하는 구조가 일반적이지만, 반드시 그런 것은 아닙니다.

예제 6: 힙과 스택의 주소 비교
```c
#include <stdio.h>
#include <stdlib.h>

int global_var = 100; // 데이터 영역

int main() {
  int local_var = 10;        // 스택
  int *heap_var = malloc(sizeof(int)); // 힙
  *heap_var = 20;

  printf("data, global_var: %p\n", (void*)&global_var);
  printf("stack, local_var : %p\n", (void*)&local_var);
  printf("heap, heap_var  : %p\n", (void*)heap_var);

  free(heap_var);
  return 0;
}
```
📌 일반적으로 스택 > 힙 > 데이터 순으로 주소가 배치됩니다.

✅ 연습 문제
1. 정수형 변수 a를 선언하고 포인터를 이용하여 값을 변경하시오.
  (힌트: 포인터를 선언하고 *p = 값 형식으로 접근)
2. 두 개의 정수를 더하는 함수를 만들되, 포인터를 사용하여 결과를 호출자에게 전달하시오.
```c
// 함수 정의
void add(int a, int b, int *result) {
    // 구현
}
```
3. 포인터를 이용해 문자열을 출력하는 코드를 작성하시오.
  (힌트: char *p = "Hello"; → while (*p) 루프 사용 가능)

📚 요약
| 항목       | 설명                        |
| -------- | ------------------------- |
| 포인터      | 메모리 주소를 저장하는 변수           |
| `&`      | 주소 연산자 (`&a` → 변수 a의 주소)       |
| `*`      | 간접 참조(역참조) 연산자 (`*p` → 주소의 값)  |
| `*ptr`   | 포인터 ptr이 가리키는 주소의 값(역참조)|
| 포인터의 크기  | 시스템 아키텍처(32/64bit)에 따라 다름 |
| 메모리 레이아웃 | 코드, 데이터, 힙, 스택으로 구성       |

다음 장에서는 포인터 연산, 배열과 포인터의 관계, 이중 포인터 등에 대해 학습합니다.
