## 1.2 단일 포인터 선언 및 초기화  
포인터를 사용하기 위해서는 포인터 변수를 선언하고, 해당 변수에 유효한 주소를 초기화해야 합니다. 이 절에서는 단일(1차) 포인터 변수의 선언 방법, 초기화, 사용법을 중점적으로 학습합니다.

### 1.2.1 포인터 변수의 선언
```c
자료형 *포인터이름;
```

* 자료형은 가리키는 대상 변수의 타입이어야 합니다.
* `*`는 포인터임을 나타냅니다.

예제 1 : 포인터 선언 방법
| 선언 예시    | 설명                   |
| ------------ | -------------------- |
| `int *p;`    | 정수형(int)을 가리키는 포인터   |
| `char *cp;`  | 문자형(char)을 가리키는 포인터  |
| `float *fp;` | 실수형(float)을 가리키는 포인터 |

📌 주의할 점: 아래처럼 선언하면 a만 포인터이고, b는 일반 변수입니다.
```c
int* a, b;     // a는 int형 포인터, b는 일반 int형 변수 (혼동 주의)
int* a;        // 일반적 표현, 비권장함
int *a;        // 권장(가독성 이유)
```
명확하게 선언하는 방법:
```c
int *a;
int b;
```
> 포인터와 일반 변수를 한 줄에 선언하지 않는 것이 좋습니다.
> 코드 리뷰나 유지보수 시 혼동을 방지할 수 있습니다.

### 1.2.2 포인터 초기화
* 포인터를 선언만 하고 초기화하지 않으면, **쓰레기 주소(undefined memory)**를 가리켜 프로그램 오류의 원인이 된다.
> 포인터는 반드시 유효한 메모리 주소 또는 NULL로 초기화해야 합니다.  
> 초기화되지 않은 포인터는 'dangling pointer'상태로 불안정합니다.

예제 2 : 안전한 초기화
```c
// int형 변수 a를 선언하고, 포인터 p에 a의 주소를 저장
int a = 10;
int *p = &a;
```
❗ 잘못된 사용 예:
초기화하지 않은 포인터를 역참조하면 운영체제가 메모리 접근을 차단해 프로그램이 강제 종료됩니다.
```c
int *ptr;       // 초기화 안됨
*ptr = 100;     // 쓰레기 주소 → Segmentation fault 가능성,프로그램 비정상 종료
```
📌 초기화되지 않은 포인터는 반드시 사용 전 NULL로 초기화하고, 조건문에서 검사해야 합니다.

### 1.2.3 포인터 사용 예제
예제 3 : 포인터 선언, 초기화, 값 접근
```c
#include <stdio.h>

int main() {
  int x = 5;
  int *p = &x;

  printf("x의 값: %d\n", x);
  printf("x의 주소: %p\n", (void*)&x);
  printf("p가 저장한 주소: %p\n", p);
  printf("p가 가리키는 값: %d\n", *p);

  *p = 20;    // 포인터를 통해 x 값 변경

  printf("변경된 x의 값: %d\n", x);

  return 0;
}
```
✔ 실행 결과:
``` text
x의 값: 5
x의 주소: 0x7ffeefa91abc
p가 저장한 주소: 0x7ffeefa91abc
p가 가리키는 값: 5
변경된 x의 값: 20
```

예제 4 : 초기화하지 않은 포인터의 위험
```c
#include <stdio.h>

int main() {
  int *ptr;    // 초기화되지 않음
  
  *ptr = 100;  // 정의되지 않은 동작, 프로그램 크래시 가능
  printf("%d\n", *ptr);
  
  return 0;
}
```

❗결과:
* 대부분의 경우 실행 중 Segmentation fault 발생
* 포인터는 반드시 유효한 주소로 초기화한 후 사용해야 합니다.

예제 5 : NULL 포인터 초기화 및 유효성 검사
```c
#include <stdio.h>

int main() {
  int *p = NULL;

  if (p != NULL) {
    printf("p가 가리키는 값: %d\n", *p);  // 안전한 역참조
  } else {
    printf("포인터는 아직 유효한 주소를 가지고 있지 않습니다.\n");
  }

  return 0;
}
```
* NULL 초기화는 포인터가 아직 어떤 객체도 가리키지 않음을 나타냅니다.
* *p 사용 전에는 반드시 NULL 체크가 필요합니다.
* NULL은 <stddef.h>에 정의된 매크로이며, 정수 0과 동일하지만 의미적으로 `주소 없음`을 표현합니다.

예제 6 : 함수 내 포인터 전달
```c
#include <stdio.h>

void show_address(int *p) {
  if (p == NULL) {
    printf("잘못된 포인터입니다.\n");
    return;    
  }
  printf("함수 내에서 p의 값(주소): %p\n", p);
  printf("p가 가리키는 값: %d\n", *p);
}

int main() {
  int num = 123;
  show_address(&num); //호출 시 &num을 전달하면 포인터 매개변수가 주소를 반는다.

  return 0;
}
```
예제 7 : 동적 메모리 할당 후 NULL 체크
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
  int *ptr = (int *)malloc(sizeof(int));
  if (ptr == NULL) {
    printf("메모리 할당 실패\n");
    return 1;
  }
  
  *ptr = 50;
  printf("동적 메모리에 저장된 값: %d\n", *ptr);

  free(ptr);  // 메모리 해제
  ptr = NULL;

  return 0;
}
```
* malloc() 후 메모리 사용 전에 꼭 NULL 체크.
* 할당된 메모리를 다 쓴 후에는 free()를 호출해 시스템 자원을 반환.


📚 요약
| 항목       | 설명                             | 예시                              |
| -------- | ------------------------------ | ------------------------------- |
| 포인터 선언   | 특정 자료형을 가리키는 변수 선언             | `int *p;`, `float *fp;`         |
| 포인터 초기화  | 주소 연산자 `&`를 사용하여 변수의 주소로 초기화   | `p = &x;`                       |
| 역참조(`*`) | 포인터가 가리키는 주소의 **값**에 접근 또는 수정  | `*p = 10;`, `printf("%d", *p);` |
| NULL 포인터 | 유효한 주소가 없음을 명시, 반드시 사용 전 검사 필요 | `if (p != NULL)`                |
| 주의사항     | 초기화되지 않은 포인터는 **절대 사용 금지**, NULL 초기화 습관화     | `int *p = NULL;` → 검사 후 사용      |

✅ 연습 문제
1. 두 개의 int형 변수 a, b를 선언하고, 포인터를 사용해 두 변수의 값을 서로 바꾸는 코드를 작성해보세요.
  - 힌트: `*pa`, `*pb`를 이용해 값을 `temp`에 임시 저장한 뒤 서로 교환해보세요.
  ```c
  int a = 10, b = 20;
  int *pa = &a;
  int *pb = &b;
  
  // 교환 코드 작성
  ```
2. float형 변수의 값을 포인터를 통해 증가시키는 예제를 작성해보세요.
  - 힌트: *pf = *pf + 1.0f; 또는 (*pf)++ 형태로 증가 가능
  ```c
  float f = 3.14f;
  float *pf = &f;
  // 포인터를 이용해 값 증가
  ```
3. 초기화되지 않은 포인터를 사용할 때 발생할 수 있는 문제를 설명하고, 이를 방지하는 방법을 코드로 작성해보세요.
  - 힌트: 포인터는 NULL로 초기화하고, 사용 전에 반드시 유효성 검사 (if (ptr != NULL))를 해야 함.
  ```c
  // 초기화되지 않은 포인터 사용 방지 예제
  #include <stdio.h>
  
  int main() {
    int *ptr = NULL;
  
    if (ptr != NULL) {
      *ptr = 10;
      printf("값: %d\n", *ptr);
    } else {
      printf("포인터는 NULL입니다. 안전하지 않으므로 사용하지 않습니다.\n");
    }
  
    return 0;
  }
  ```


