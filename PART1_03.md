## 1.3 포인터 연산과 산술 작업 (Pointer Arithmetic)  
포인터는 단순히 주소를 저장하는 변수일 뿐만 아니라, 산술 연산(+, -, ++) 등을 적용할 수 있는 특수한 변수입니다. 포인터 산술은 주로 배열 탐색, 메모리 접근 제어, 반복 처리 등에 활용됩니다.

### 1.3.1 포인터 산술이란?
C 언어에서 포인터는 자료형에 따라 일정 크기만큼 이동합니다.

예를 들어,
```c
int *p;
p++;
```
이 경우 p는 4바이트(int) 단위로 증가하며, 다음 int 요소를 가리킵니다.

### 1.3.2 사용 가능한 연산
| 연산자    | 설명                             |
| --------- | -------------------------------- |
| `p++`     | 포인터가 가리키는 주소를 다음 요소로 이동|
| `p--`     | 이전 요소로 이동                       |
| `p + n`   | n번째 이후 주소를 반환                 |
| `p - n`   | n번째 이전 주소를 반환                 |
| `p1 - p2` | 두 포인터 사이의 거리 (단위는 해당 타입 크기 기준) |
> `p + 1`은 실제로 포인터 p를 변경하는 것이 아니라, "p가 가리키는 다음 주소"를 반환합니다.
> 포인터 자체를 이동시키려면 `p = p + 1;` 또는 `p++`처럼 명시적으로 재할당해야 합니다.

📌 포인터끼리 덧셈은 허용되지 않음 (p1 + p2 → X)

예제 1: 포인터 증가 (p++)
```c
#include <stdio.h>

int main() {
  int arr[] = {10, 20, 30, 40};
  int *p = arr;

  printf("현재 값: %d\n", *p);  // 10
  p++;
  printf("다음 값: %d\n", *p);  // 20
  p++;
  printf("또 다음 값: %d\n", *p);  // 30

  return 0;
}
```

예제 2: 포인터로 배열 탐색
```c
#include <stdio.h>

int main() {
  int arr[] = {5, 10, 15, 20, 25};
  int *p = arr;

  for (int i = 0; i < 5; i++) {
      printf("arr[%d] = %d\n", i, *(p + i));
  }

  return 0;
}
```
배열 요소 접근: *(p + i) = arr[i]

예제 3: 포인터 차이 계산
```c
#include <stdio.h>

int main() {
  int arr[] = {1, 2, 3, 4, 5};
  int *p1 = &arr[1];  // 주소: arr + 1
  int *p2 = &arr[4];  // 주소: arr + 4

  int diff = p2 - p1;
  printf("포인터 사이의 거리: %d\n", diff);  // 3

  return 0;
}
```
📌 주의할 점
>1. 포인터가 배열 범위를 벗어나지 않도록 주의
>2. 포인터끼리 덧셈은 불가능
>3. char * 타입의 경우 1바이트씩 이동 (문자 처리 유용)

예제 4: char * 포인터 연산
```c
#include <stdio.h>

int main() {
  char str[] = "Hello";
  char *p = str;

  while (*p != '\0') {
      printf("%c ", *p);
      p++;
  }

  return 0;
}
```

출력: H e l l o

### 1.3.3 `*p++` vs `(*p)++`
예제 5: 포인터 증감과 간접 참조
```c
#include <stdio.h>

int main() {
  int a = 10;
  int *p = &a;

  printf("p: %p\n", p);
  printf("*p: %d\n", *p);

  (*p)++;     // a 값 증가
  printf("a after (*p)++: %d\n", a);

  return 0;
}
```
예제 6: 포인터 증감과 이동
```c
#include <stdio.h>

int main() {
  int arr[] = {10, 20, 30};
  int *p = arr;

  printf("p     : %p\n", p);
  printf("*p++  : %d\n", *p++);   // 10 출력후 p는 arr+1로 이동, p = arr[1]
  printf("(*p)++: %d\n", (*p)++); // 20, 값 20 출력후 p가 가리키는 값 21로 증가

  return 0;
}
```
📌 `*p++` → *(p++) 와 같음 → 값을 읽고 포인터 이동
📌 `(*p)++` → p가 가리키는 값 증가, 포인터는 그대로
> ℹ️ 참고: int *p = arr; 는 배열의 첫 요소를 가리키는 포인터입니다.
> 하지만 int (*p)[5] = &arr; 와 같은 문장은 배열 전체를 가리키는 포인터로, 개념이 다릅니다.
> 이 내용은 고급 섹션에서 자세히 다룹니다.

📚 실수 방지 팁
| 실수                   | 설명                          |
| -------------------- | --------------------------- |
| 포인터를 배열처럼 사용하다 범위 초과 | `p++` 반복 시 경계 확인 필요         |
| `*p++` 사용 시 괄호 오용    | `(*p)++`와 `*p++`는 의미 다름     |
| 포인터끼리 덧셈 사용          | `p1 + p2` 불가. `p1 - p2`는 가능 |

### 1.3.4 포인터 차이 연산 결과
```c
int arr[] = {1, 2, 3, 4, 5};
int *p1 = &arr[1];  // arr + 1
int *p2 = &arr[4];  // arr + 4

int diff = p2 - p1; // 4 - 1 = 3 (int 기준 3칸 차이)
```
📌 단위는 바이트(byte)가 아니라 요소 개수입니다. (int 기준이면 4바이트 × 3칸 = 실제 메모리상 12바이트 차이)

✅ 연습 문제

1. 다음 배열을 포인터만 사용하여 역순으로 출력해보세요:
```c
int data[] = {1, 2, 3, 4, 5};
int *p = data + 4;

for (int i = 0; i < 5; i++) {
    printf("%d ", *(p - i));
}
```

2. int 배열을 포인터로 순회하면서 모든 요소의 합을 구하는 코드를 작성하세요.
```c
int arr[] = {1, 2, 3, 4, 5};
int *p = arr;
int sum = 0;

for (int i = 0; i < 5; i++) {
  sum += *(p + i);  // 또는 sum += *p++;
}
printf("합계: %d\n", sum);
```

3. 다음 포인터 연산의 결과를 설명하세요:
```c
int arr[] = {10, 20, 30};
int *p = arr;
printf("%d\n", *(++p)); // 20 → 먼저 p가 증가하고, 그 위치 값을 출력
printf("%d\n", (*p)++); // 20 → 값을 출력한 후, 21로 증가
```

📚 요약
| 연산            | 의미                    | 예시                    |
| ------------- | --------------------- | --------------------- |
| `p++` / `++p` | 포인터가 다음 요소로 이동        | `*p++` = 현재 값 참조 후 이동 |
| `p + n`       | n번째 이후 주소 반환 (p는 그대로) | `*(p + 2)`            |
| `*p++`        | 현재 값 출력 후 포인터 증가      | `*p++`                |
| `(*p)++`      | 현재 값 증가 후 포인터 유지      | `(*p)++`              |
| `p1 - p2`     | 두 포인터 간 거리(요소 수 단위)   | `p2 - p1 = 3`         |
| `p1 + p2`     | ❌ 허용되지 않음 (컴파일 오류 발생) | -                     |


