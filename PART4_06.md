🔹 4.6 포인터 산술과 경계 검사 누락  
✅ 개요

* C/C++에서 포인터 산술(pointer arithmetic)은 배열이나 메모리 블록을 탐색할 때 매우 유용합니다.

* 하지만 경계(boundary) 검사를 하지 않고 포인터를 이동하면,
* 배열 또는 할당된 메모리 영역을 벗어나서 접근하는 오류가 발생합니다.

이로 인해 버퍼 오버플로우(buffer overflow), 정의되지 않은 동작(UB), 심지어 보안 취약점이 발생할 수 있습니다.

✅ 포인터 산술 기본

포인터에 정수를 더하거나 빼면, 포인터는 자료형 크기 단위로 이동합니다.
```cpp
int arr[5] = {10, 20, 30, 40, 50};
int* p = arr;  // arr[0]의 주소

p = p + 2;     // 이제 p는 arr[2] (값 30) 가리킴
```
✅ 경계 검사 누락 예시
```cpp
int arr[3] = {1, 2, 3};
int* p = arr;

for (int i = 0; i <= 3; ++i) {   // ❌ i=3까지 접근 → 범위 벗어남
    std::cout << *(p + i) << std::endl;
}
```

* 배열 크기가 3인데, i <= 3 조건으로 p+3까지 접근 → 초과 접근

* 프로그램 동작이 이상해지거나 크래시 발생 가능

✅ 안전한 경계 검사 방법
```cpp
for (int i = 0; i < 3; ++i) {
    std::cout << *(p + i) << std::endl;  // 정상 접근
}
```

또는 배열 크기를 상수나 sizeof를 이용해 자동 계산:
```cpp
int n = sizeof(arr) / sizeof(arr[0]);
for (int i = 0; i < n; ++i) {
    std::cout << *(p + i) << std::endl;
}
```
✅ 더 위험한 상황: 동적 배열
```cpp
int* p = new int[5]{1,2,3,4,5};

// 경계 검사 없이 무한 루프
for (int i = 0; i < 10; ++i) {
    std::cout << p[i] << std::endl;  // ❌ i >= 5일 때 위험
}

delete[] p;
```
✅ 포인터 산술 주의점

* 포인터 연산 시 항상 할당된 메모리 크기 내에서만 이동

* 배열 또는 할당 크기를 정확히 알고, 넘지 않도록 코딩

* 함수 인자로 포인터와 크기를 같이 전달하는 습관

✅ STL 사용 권장

* C++에서는 std::vector나 std::array 같은 컨테이너를 사용하여
자동 경계 검사 또는 안전한 접근 메서드(at()) 활용 가능
```cpp
std::vector<int> v = {1,2,3};
for (size_t i = 0; i < v.size(); ++i) {
    std::cout << v.at(i) << std::endl;  // at()은 범위 검사 포함
}
```
📌 요약
| 문제점         | 설명                    | 방지법                     |
| ----------- | --------------------- | ----------------------- |
| 경계 검사 누락    | 포인터가 배열 크기 넘어선 메모리 접근 | 배열 크기 철저 관리, 조건문 엄격히 설정 |
| 포인터 산술 오용   | 잘못된 위치로 포인터 이동        | 포인터 연산 시 자료형 크기와 범위 고려  |
| 동적 배열 과다 접근 | 할당 크기 넘어 접근           | 크기 정보 항상 같이 관리 및 전달     |
