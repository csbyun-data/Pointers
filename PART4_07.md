🔹 4.7 다중 포인터 사용 시 주의점  
✅ 개요

* 다중 포인터는 포인터가 또 다른 포인터를 가리키는 구조입니다.

* 예) int** pp는 int*를 가리키는 포인터입니다.

* 복잡한 데이터 구조 (예: 2D 배열, 연결 리스트, 동적 배열 등)에서 자주 사용됨.

* 다중 포인터 사용 시 주소와 값, 메모리 할당 관리가 복잡해 실수가 잦음.

✅ 주요 주의사항

1. 메모리 할당 시 중복 및 누락 주의
```cpp
int** arr = new int*[3];  // 1차원 배열 할당

for (int i = 0; i < 3; ++i) {
    arr[i] = new int[4];  // 2차원 배열 각 행 할당
}
```

* 할당한 만큼 정확히 해제 필요
```cpp
for (int i = 0; i < 3; ++i) {
    delete[] arr[i];
}
delete[] arr;
```

2. 포인터 레벨 구분 명확히 하기

* int* p와 int** pp를 혼동하면 잘못된 참조나 해제가 발생함.
```cpp
int a = 10;
int* p = &a;
int** pp = &p;

std::cout << **pp << std::endl;  // 10
```

3. 이중 포인터를 함수 매개변수로 사용할 때

* 이중 포인터는 포인터를 변경하거나, 동적 메모리 할당된 포인터를 함수 안에서 수정할 때 사용
```cpp
void allocate(int** p) {
    *p = new int(100);
}

int* ptr = nullptr;
allocate(&ptr);
std::cout << *ptr << std::endl;  // 100

delete ptr;
```

4. 포인터 해제 순서 중요

* 다중 포인터는 내부 포인터부터 해제 후 외부 포인터 해제
```cpp
for (int i = 0; i < 3; ++i) {
    delete[] arr[i];  // 내부 배열 해제
}
delete[] arr;         // 외부 배열 해제
```

✅ 다중 포인터 실수 예시

* 내부 배열 할당 누락 후 외부 배열 해제
```cpp
int** arr = new int*[3];
// 내부 배열 할당 안함
delete[] arr;   // 내부 배열 해제 안해서 메모리 누수 발생
```

* 함수에서 포인터 인자 잘못 처리
```cpp
void wrongFunc(int** p) {
    p = new int*[10];  // 잘못된 할당, 원본 포인터 변경 X
}

int** ptr = nullptr;
wrongFunc(ptr);
// ptr은 여전히 nullptr
```

✅ 요약 및 권장 사항
| 주의점          | 설명                        | 권장 방법             |
| ------------ | ------------------------- | ----------------- |
| 메모리 할당/해제 정확 | 모든 동적 할당에 대해 정확히 해제       | 내부 → 외부 순서로 해제    |
| 포인터 수준 명확화   | `int*`, `int**` 혼동 주의     | 변수 선언과 함수 시그니처 주의 |
| 함수 인자 사용법    | 이중 포인터로 포인터 변경 시 주소 전달    | 포인터 주소 `&ptr` 전달  |
| 스마트 포인터 제한   | 스마트 포인터는 다중 포인터 대신 신중히 사용 | 경우에 따라 RAII 패턴 고려 |

📌 실전 팁

* 다중 포인터 대신 STL 컨테이너(std::vector<std::vector<int>>) 활용 권장

* RAII 패턴 및 스마트 포인터로 메모리 관리 자동화

* 복잡한 포인터 연산은 코드 가독성 위해 함수 분리 및 주석 작성 필수
