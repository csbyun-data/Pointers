🔹 4.8 배열과 포인터 혼동 문제  
✅ 배열과 포인터의 기본 차이
| 구분        | 배열                     | 포인터                   |
| --------- | ---------------------- | --------------------- |
| 선언        | `int arr[5];`          | `int* p;`             |
| 메모리       | 컴파일 시 고정 크기 할당         | 런타임에 동적 할당 가능         |
| 이름의 역할    | 배열의 첫 번째 요소 주소로 암묵적 변환 | 별도의 메모리 주소 저장         |
| sizeof 결과 | 배열 전체 크기               | 포인터 크기 (보통 4 또는 8바이트) |
| 주소 변경 가능  | 불가능 (배열 이름은 상수 주소)     | 가능 (`p = arr + 1;`)   |

✅ 혼동으로 인한 오류 예시

1. sizeof 차이
```cpp
int arr[10];
int* p = arr;

std::cout << sizeof(arr) << std::endl;  // 40 (int 4바이트 * 10)
std::cout << sizeof(p) << std::endl;    // 8 (포인터 크기)

```
2. 배열 이름에 대입 시 오류
```cpp
int arr[5];
arr = arr + 1;  // ❌ 컴파일 에러: 배열 이름은 주소 변경 불가
```

3. 포인터를 배열처럼 접근 가능하지만 주의
```cpp
int* p = new int[5];
p[0] = 10;      // 가능
p = p + 1;      // 주소 이동 가능
```
✅ 함수 인자에서 배열과 포인터

* 배열을 함수 인자로 넘기면 사실상 포인터로 전달됨
```cpp
void func(int arr[]) {  // 실제로는 int* arr 와 동일
    std::cout << sizeof(arr) << std::endl;  // 포인터 크기 출력
}

int main() {
    int arr[10];
    func(arr);
}
```
✅ 배열 포인터 vs 포인터 배열 혼동

* 배열 포인터: 포인터가 배열을 가리킴
```cpp
int (*p)[5];   // 5개 int 배열을 가리키는 포인터
```

* 포인터 배열: 포인터들의 배열
```cpp
int* p[5];     // 5개의 int*를 담는 배열
```

✅ 주의해야 할 부분

* 배열 이름은 상수 주소 → 주소 변경 불가

* 포인터는 자유롭게 주소 변경 가능

* 함수 인자에서 배열은 포인터로 취급 → 크기 정보 소실 주의

* 동적 할당 후 포인터는 반드시 해제 필요

✅ 요약
| 항목             | 핵심 포인트                   |
| -------------- | ------------------------ |
| 배열 이름          | 상수 포인터처럼 동작, 주소 변경 불가    |
| 포인터            | 변수처럼 주소 변경 가능            |
| sizeof         | 배열은 전체 크기, 포인터는 주소 크기    |
| 함수 인자          | 배열 → 포인터로 변환, 크기 정보는 사라짐 |
| 배열 포인터와 포인터 배열 | 선언법 다르고 사용 목적 다름         |
