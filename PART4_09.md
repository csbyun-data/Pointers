🔹 4.9 동적 메모리 할당 후 크기 계산 문제  
✅ 개요

C/C++에서 동적 메모리를 할당할 때는 얼마만큼의 공간을 확보할지 정확히 계산해야 합니다.
크기 계산이 잘못되면 다음과 같은 문제가 발생할 수 있습니다:

* 버퍼 오버플로우

* 미할당 영역 접근

* 불필요한 낭비

* 할당 후 크기 알 수 없음

✅ 문제 상황 1: 크기 계산 실수  
❌ 잘못된 예
```c
int* arr = (int*)malloc(10);  // 10바이트만 할당 → int 2개도 안 됨
```

* int는 보통 4바이트 → 10바이트로는 int 2개를 다 저장 못 함

✅ 올바른 예
```c
int* arr = (int*)malloc(sizeof(int) * 10);  // int 10개 공간 확보
```

항상 sizeof(자료형)을 곱해야 자료형에 맞는 정확한 바이트 수를 계산할 수 있습니다.

✅ 문제 상황 2: new[]와 포인터 크기 혼동
```cpp
int* arr = new int[5];

// 할당된 메모리의 바이트 크기를 구할 수 있을까?
std::cout << sizeof(arr) << std::endl;  // ❌ 결과는 포인터 크기 (4 or 8바이트)
```

* sizeof(arr)는 배열 크기가 아니라 포인터의 크기만 알려줍니다.

* new로 동적 할당한 메모리의 총 크기는 할당 당시 저장해두거나,
따로 관리하지 않으면 추적할 수 없습니다.

✅ 해결 방법: 크기 별도 저장
```cpp
int size = 10;
int* arr = new int[size];

// 사용 중에는 size 변수 활용
for (int i = 0; i < size; ++i) {
    arr[i] = i * 10;
}

delete[] arr;
```

C/C++은 동적 메모리의 실제 크기를 알 수 있는 표준 방법을 제공하지 않으므로
사용자가 명확하게 크기를 저장하고 관리해야 합니다.

✅ STL 사용 시 이 문제 해결 가능
```cpp
std::vector<int> vec(10);

// 크기 확인
std::cout << vec.size() << std::endl;

// 안전하게 값 접근
vec[0] = 42;
```

* std::vector는 내부적으로 메모리 크기 관리와 할당을 자동 처리함

* resize(), push_back() 등 유연하게 조절 가능

✅ 요약
| 실수 유형                 | 설명                                      |
| --------------------- | --------------------------------------- |
| `malloc(정수)`만 사용      | 자료형 크기 고려 안 해서 메모리 부족 발생 가능             |
| `sizeof(포인터)` 사용      | 실제 배열 크기 아님 (항상 포인터 크기만 반환)             |
| `new[]`로 할당한 배열 크기 모름 | 배열 크기 따로 저장해두지 않으면 사용 중 혼동 발생           |
| 해결책                   | `sizeof(type) * 개수`, 크기 변수 저장, STL 사용 등 |
