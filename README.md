# Pointers in C/C++
###  1	메모리 레이아웃
### 2	포인터
  * 2.1	단일 포인터
    * 2.1.1	포인터 선언, 초기화
    * 2.1.2	Variable Pointer, NULL Pointer
    * 2.1.3	ASCII code및 연산자 표현
    * 2.1.4	Address 연산자(&)
    * 2.1.5	Pointer로 가리킨 주소 안의 값을 변경
    * 2.1.6	Void pointer (void *)
  * 2.2	2중 포인터
### 3	포인터 유형
  * 3.1	NULL pointer
  * 3.2	Void pointer
    * 3.2.1	Void pointer
    * 3.2.2	Void pointer의 역참조
    * 3.2.3	Void pointer를 사용하는 이유?
    * 3.2.4	Void pointer 산술연산
    * 3.2.5	Void pointer함수에 사용
    * 3.2.6	Void pointer 단점
    * 3.2.7	Void pointer 장점
  * 3.3	Wild pointer
  * 3.4	Dangling pointer
### 4	포인터 산술작업
  * 4.1	Pointer 산술
  * 4.2	Pointer 증가 프로그램
  * 4.3	Structure의 size 계산
  * 4.4	pointer요소간의 거리 계산
  * 4.5	pointer 요소간의 비교
  * 4.6	간접 참조 연산자 증가/감소 operator 사용
  * 4.7	간접 참조 연산자와 증감 연산자
### 5	포인터와 문자열
### 6	포인터와 배열
  * 6.1	배열과 포인터
    * 6.1.1	1차원 배열과 포인터
    * 6.1.2	Pointer와 문자 배열의 관계
    * 6.1.3	Pointer를 이용한 배열의 모든 요소 접근
    * 6.1.4	Pointer를 이용한 방법의 장점 (index표기법, 포인터 사용)
    * 6.1.5	2차원 배열과 포인터
    * 6.1.6	포인터와 배열
    * 6.1.7	포인터를 배열처럼 사용
    * 6.1.8	배열 매개변수
  * 6.2 배열
    * 6.2.1	1차원 배열
    * 6.2.2	1차원 포인터 인자로 전달
    * 6.2.3	크기가 정의된 배열을 인자로 전달
    * 6.2.4	크기가 정의되지 않은 배열을 인자로 전달
    * 6.3.1	포인터 인자, 매크로, 전역상수로 전달
    * 6.3.2	행을 생략, 열만 전달
    * 6.3.3	2차 포인터 배열로 전달
    * 6.3.4	단일 포인터로 전달
    * 6.4.1	포인터와 배열의 관계
    * 6.4.2	단일 포인터를 사용한 2차원 배열 접근
    * 6.4.3	배열 포인터를 사용한 2차원 배열 접근
    * 6.5.1	정렬되지 않은 int형 합
    * 6.5.2	정렬된 int형 합
    * 6.5.3	결론
    * 6.5.4	정렬되지 않은 int형을 빠르게 계산하기 위한 변형
### 7	가변 배열과 Dynamic배열
  * 7.1	가변 배열
  * 7.2	Dynamic 배열
### 8	동적 메모리 할당
  * 8.1
    * 8.1.1	메모리 할당, 해제 malloc(), free() 함수
    * 8.1.2	메모리 할당의 단점
    * 8.1.3	함수 malloc(), calloc(), realloc(), free() 함수
    * 8.1.4	C++ new와 malloc(), delete와 free() 비교
  * 8.2 
    * 8.2.1	1D int형 동적배열 할당
    * 8.2.2	C++ new, delete operator
    * 8.2.3	2D int형 동적배열 할당
    * 8.2.4	C++ 2D int형 동적배열 할당
    * 8.2.5	2D char형 동적배열 할당
    * 8.2.6	C++ 3D int형 동적배열 할당
    * 8.2.7	C++ class 배열 동적 할당
  * 8.3	Dynamically 2D array in C using the single pointer
  * 8.4	Pointer to string array in C
    * 8.4.1	2차원 배열 사용한 문자열
    * 8.4.2	String pointer 배열을 사용한 문자열
    * 8.4.3	배열 포인터를 사용하여 2D문자 배열 접근
    * 8.4.4	배열 포인터와 포인터의 포인터를 사용하여 문자열 배열 접근
  * 8.5	문자열 포인터 배열에 대한 몇 가지 잘못된 작업
  * 8.6	메모리 할당 coding 실수
    * 8.6.1	Null pointer 점검
    * 8.6.2	할당된 메모리 값을 초기화하지 않고 사용
    * 8.6.3	할당 해제된 메모리의 주소를 사용, 포인터는 해제후에도 같은 주소를 가르키고 있음
    * 8.6.4	해제된 메모리를 또 해제를 함
    * 8.6.5	메모리 할당되지 않은 포인터를 해제
    * 8.6.6	할당된 메모리 해제를 하지 않음
    * 8.6.7	메모리 할당보다 정규 배열 사용을 권장, 배열은 컴파일러에서 자동해제함, 배열이 빠름
    * 8.6.8	동적 배열에서 sizeof() 사용하지 말 것, 동적 배열주소 크기가 반환됨
    * 8.6.9	메모리 할당 개수, 해제 개수counter
    * 8.6.10	메모리 할당 범위를 벗아난 접근
    * 8.6.11	포인터를 재할당하여 참조를 손실함
    * 8.6.12	메모리를 할당하지 않고 값을 입력, dangling pointer
  * 8.7	메모리 할당 개수, 해제 개수 counter
### 9	포인터 구조체
### 10	함수 포인터
  * 10.1 
    * 10.1.1	함수 포인터 정의
    * 10.1.2	호출 규약
    * 10.1.3	함수 포인터 주소할당
    * 10.1.4	함수 포인터 비교
    * 10.1.5	함수 포인터를 이용한 함수 호출
    * 10.1.6	함수 포인터 인수 전달
    * 10.1.7	함수 포인터 반환
    * 10.1.8	함수 포인터 배열 사용
  * 10.2	콜백 함수 구현
    * 10.2.1	콜백 함수 개념
    * 10.2.2	콜백 함수 구현
    * 10.2.3	Qsort() 함수
    * 10.2.4	Static C++ member function
    * 10.2.5	Non-static C++ Member function
  * 10.3	Functors
    * 10.3.1	Functors 구현
    * 10.3.2	Functors 사용 예제
### 11	파일 I/O
### 12	포인터 사용하는 일반적인 실수
  * 12.1	Pointer를 초기화하지 않음
  * 12.2	포인터의 비교
  * 12.3	Dynamic memory할당을 이용한 포인터 선언
  * 12.4	유효하지 않은 address를 가르키는 pointer
