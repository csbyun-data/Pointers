# Pointers in C/C++
###  1	메모리 레이아웃
  * 1.1 변수와 메모리의 관계
    * 1.1.1 변수 선언과 메모리 구조
    * 1.1.2 변수의 주소 구하기 (&)
  * 1.2 포인터의 크기와 자료형
  * 1.3 함수의 매개변수 전달 방식
    * 값의 의한 전달( Call by Value)
### 2	포인터
  * 2.1	단일 포인터
    * 2.1.1	포인터 선언, 초기화
    * 2.1.2	ASCII code및 연산자 표현
    * 2.1.3	Address 연산자(&), 간접 참조 연산자 (*)
    * 2.1.4	Pointer로 가리킨 주소 안의 값을 변경
  * 2.2	2중 포인터
### 3	포인터 유형
  * 3.1	NULL pointer
  * 3.2	Void pointer
    * 3.2.1	Void pointer (void *)
    * 3.2.2	Void pointer의 역참조
    * 3.2.3	Void pointer를 사용하는 이유?
    * 3.2.4	Void pointer 산술연산
    * 3.2.5	Void pointer함수에 사용
    * 3.2.6	Void pointer 단점
    * 3.2.7	Void pointer 장점
  * 3.3	Wild pointer
  * 3.4	Dangling pointer
### 4	포인터 산술작업
  * 4.1	Pointer 산술
  * 4.2	Pointer 증가 프로그램
  * 4.3	Structure의 size 계산
  * 4.4	pointer요소간의 거리 계산
  * 4.5	pointer 요소간의 비교
  * 4.6	간접 참조 연산자 증가/감소 operator 사용
  * 4.7	간접 참조 연산자와 증감 연산자
### 5	포인터와 문자열
  * 5.1 문자열 개념
    * 5.1.1 문자열 상수와 문자열 배열
    * 5.1.2 문자열 입력/출력 함수 (scanf, gets, fgets, puts, 등)
    * 5.1.3 문자열 종료문자(\0)
  * 5.2 문자열과 포인터
    * 5.2.1 문자열을 포인터 선언
    * 5.2.2 배열, 포인터를 이용한 문자열 저장
    * 5.2.3 문자열 포인터의 위험성(읽기 전용 메모리)
    * 5.2.4 문자열 함수 구현( strlen, strcpy, strcmp)
  * 5.3 동적 메모리 할당과 문자열
    *  5.3.1 문자열 복사 및 조작 시 동적 메모리 활용
    *  5.3.2 메모리 누수와 안전한 프로그래밍
  * 5.4	문자열 배열
    * 5.4.1	2차원 배열 사용한 문자열
    * 5.4.2	String pointer 배열을 사용한 문자열
    * 5.4.3	배열 포인터를 사용하여 2D문자 배열 접근
    * 5.4.4	배열 포인터와 포인터의 포인터를 사용하여 문자열 배열 접근
    * 5.4.5 이중 포인터(char **)와 문자열 배열
  * 5.5	문자열 포인터 배열에 대한 몇 가지 잘못된 작업
### 6	포인터와 배열
  * 6.1	배열과 포인터
    * 6.1.1	1차원 배열과 포인터
    * 6.1.2	Pointer와 문자 배열의 관계
    * 6.1.3	Pointer를 이용한 배열의 모든 요소 접근
    * 6.1.4	Pointer를 이용한 방법의 장점 (index표기법, 포인터 사용)
    * 6.1.5	2차원 배열과 포인터
    * 6.1.6	포인터를 배열처럼 사용
    * 6.1.7	배열 매개변수
  * 6.2 배열
    * 6.2.1	1차원 배열
    * 6.2.2	1차원 포인터 인자로 전달
    * 6.2.3	크기가 정의된 배열을 인자로 전달
    * 6.2.4	크기가 정의되지 않은 배열을 인자로 전달
  * 6.3 포인터 인자
    * 6.3.1	포인터 인자, 매크로, 전역상수로 전달
    * 6.3.2	행을 생략, 열만 전달
    * 6.3.3	2차 포인터 배열로 전달
    * 6.3.4	단일 포인터로 전달
 * 6.4 포인터와 배열의 관계
    * 6.4.1	포인터와 배열의 관계
    * 6.4.2	단일 포인터를 사용한 2차원 배열 접근
    * 6.4.3	배열 포인터를 사용한 2차원 배열 접근
 * 6.5 정렬되지 안은 배열과 정렬된 배열의 계산
    * 6.5.1	정렬되지 않은 int형 합
    * 6.5.2	정렬된 int형 합
    * 6.5.3	결론
    * 6.5.4	정렬되지 않은 int형을 빠르게 계산하기 위한 변형
### 7	가변 배열과 Dynamic배열
  * 7.1	가변 배열(Variable Length Array, VLA)
    * 7.1.1 VLA의 문법과 선언
    * 7.1.2 VLA의 조건과 제약사항
      * C99 표준 이상
      * 함수 내부에서만 사용가능
    * 7.1.3 VLA의 장점과 단점
    * 7.1.4 VLA 예제 code
  * 7.2 다차원 가변 배열
    * 7.2.1 2차원 VLA 선언과 사용
    * 7.2.2 함수 인자로 VLA전달
  * 7.3 가변 배열과 동적 배열 비교
    * 7.3.1 메모리 할당 시점
    * 7.3.2 유효 범위와 생존 기간
    * 7.3.3 성능 차이
    * 7.3.4 표준 지원 여부 (C99, C11)
    * 7.3.5 사용 시기와 용도 구분
### 8	동적 메모리 할당과 Dynamic 배열
  * 8.1
    * 8.1.1	메모리 할당, 해제 malloc(), free() 함수
    * 8.1.2	메모리 할당의 단점
    * 8.1.3	함수 malloc(), calloc(), realloc(), free() 함수
    * 8.1.4	C++ new와 malloc(), delete와 free() 비교
  * 8.2 
    * 8.2.1	1D int형 동적배열 할당
    * 8.2.2	C++ new, delete operator
    * 8.2.3	2D int형 동적배열 할당
    * 8.2.4	C++ 2D int형 동적배열 할당
    * 8.2.5	2D char형 동적배열 할당
    * 8.2.6	C++ 3D int형 동적배열 할당
    * 8.2.7	C++ class 배열 동적 할당
  * 8.3	Dynamically 2D array in C using the single pointer
  * 8.4	메모리 할당 coding 실수
    * 8.4.1	Null pointer 점검
    * 8.4.2	할당된 메모리 값을 초기화하지 않고 사용
    * 8.4.3	할당 해제된 메모리의 주소를 사용, 포인터는 해제후에도 같은 주소를 가르키고 있음
    * 8.4.4	해제된 메모리를 또 해제를 함
    * 8.4.5	메모리 할당되지 않은 포인터를 해제
    * 8.4.6	할당된 메모리 해제를 하지 않음
    * 8.4.7	메모리 할당보다 정규 배열 사용을 권장, 배열은 컴파일러에서 자동해제함, 배열이 빠름
    * 8.4.8	동적 배열에서 sizeof() 사용하지 말 것, 동적 배열주소 크기가 반환됨
    * 8.4.9	메모리 할당 개수, 해제 개수counter
    * 8.4.10	메모리 할당 범위를 벗아난 접근
    * 8.4.11	포인터를 재할당하여 참조를 손실함
    * 8.4.12	메모리를 할당하지 않고 값을 입력, dangling pointer
  * 8.5	메모리 할당 개수, 해제 개수 counter 예제
### 9	포인터 구조체
  * 9.1 구조체
    * 9.1.1 선언 및 초기화
    * 9.1.2 구조체 멤버 접근(.연산자)
  * 9.2 구조체와 포인터의 결합
    * 9.2.1 구조체 포인터 선언
    * 9.2.2 구조체 주소 저장 및 사용
    * 9.2.3 구조체 포인터를 통한 멤버 접근
  * 9.3 구조체 배열과 포인터
    * 9.3.1 구조체 배열 선언과 초기화
    * 9.3.2 구조체 배열을 포인터로 접근
    * 9.3.3 반복문을 통한 구조체 배열 탐색
  * 9.4 구조체와 함수
    * 9.4.1 구조체 포인터를 함수 인자로 전달
    * 9.4.2 구조체 데이터를 포인터로 반환하기
    * 9.4.3 구조체를 반환하는 함수, 포인터 반환의 차이점
    * 9.4.4 구조체 배열을 함수에 포인터로 전달
  * 9.5 동적 구조체 생성
    * 9.5.1 구조체의 대한 동적 메모리 할당
    * 9.5.2 malloc()을 이용한 구조체 포인터 생성
    * 9.5.3 구조체 배열의 동적 생성
    * 9.5.4 포인터를 이용한 구조체 배열의 동적 처리
    * 9.5.4 메모리 해제
  * 9.6 중첩 구조체와 포인터
    * 9.6.1 구조체 안에 다른 구조체 포함
    * 9.6.2 구조체 안의 포인터 맴버 접근
    * 9.6.3 이중 구조체 포인터 사용 예
  * 9.7 포인터를 맴버로 가지는 구조체
    * 9.7.1 문자열(char *)을 포함하는 구조체
    * 9.7.2 포인터 멤버에 동적 메모리 할당
    * 9.7.3 메모리 관리 주의사항
### 10 연결 리스트 구조
  * 10.1 자기 참조 구조체 이해
  * 10.2 구조체 포인터를 이용한 노드 생성 및 연결
  * 10.3 연결 리스트 삽입, 삭제 예제

### 11	함수 포인터
  * 11.1 함수 포인터
    * 11.1.1	함수 포인터 정의
    * 11.1.2	호출 규약
    * 11.1.3	함수 포인터 주소할당
    * 11.1.4	함수 포인터 비교
    * 11.1.5	함수 포인터를 이용한 함수 호출
    * 11.1.6	함수 포인터 인수 전달
    * 11.1.7	함수 포인터 반환
    * 11.1.8	함수 포인터 배열 사용
  * 11.2	콜백 함수 구현
    * 11.2.1	콜백 함수 개념
    * 11.2.2	콜백 함수 구현
    * 11.2.3	Qsort() 함수
    * 11.2.4	Static C++ member function
    * 11.2.5	Non-static C++ Member function
  * 11.3	Functors
    * 11.3.1	Functors 구현
    * 11.3.2	Functors 사용 예제
### 12	파일 I/O
  * 12.1 파일 포인터
  * 12.2 파일 함수 소개
  * 12.3 구조체 배열과 포인터 활용
  * 12.4 구조체 배열을 파알애 저장
    * 12.4.1 구조체 배열의 데이터를 텍스트 파일에 저장
    * 12.4.2 fprintf()와 반복문 활용
    * 12.4.3 저장시 포멧 설계 ( CSV, 공백 구분 등) 
  * 12.5 파일에서 구조체 배열 읽어오기
    * 12.5.1 텍스트 파일에서 구조체 배열로 데이터 불러오기
    * 12.5.2 fscanf(), fgets(), sscanf() 조합
    * 파일 끝(EOF)까지 읽는 루프 구현
  * 12.6 동적 구조체 배열 + 파일 연동
    * 파일 크기 또는 데이터 개수를 미리 알 수 없는 경우
    * realloc()을 이용한 구조체 배열 확장
    * 실시간 사용자 입력 -> 파일 저장 + 불러오기
  * 12.7 파일 입출력 오류 처리
    *  12.7.1 파일 열기 실패 처리
    *  12.7.2. 파일 경로, 권한 문제
    *  12.7.3 버퍼 문제 및 fflush(stdin) 사용 주의
  * 12.8 이진 파일 입출력
    * fwrite(), fread() 사용법
    * 바이너리 파일 저장과 로딩
    * 구조체의 padding 이슈와 해결법
### 13포인터 사용하는 일반적인 실수
  * 13.1	Pointer를 초기화 누락
  * 13.2	포인터의 비교
  * 13.3	Dynamic memory할당을 이용한 포인터 선언
  * 13.4	유효하지 않은 address를 가르키는 pointer
  * 13.5 할당 메모리 이중해제
